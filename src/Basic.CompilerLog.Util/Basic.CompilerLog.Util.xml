<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Basic.CompilerLog.Util</name>
    </assembly>
    <members>
        <member name="P:Basic.CompilerLog.Util.BasicAnalyzerHostOptions.AnalyzerDirectory">
            <summary>
            In the case analyzers are realized on disk for evaluation this is the base directory they should 
            be in.
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.BasicAnalyzerHostOptions.Cacheable">
            <summary>
            When true requests for the exact same set of analyzers will return 
            the same <see cref="T:Basic.CompilerLog.Util.BasicAnalyzerHost"/> instance.
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.BasicAnalyzerKind">
            <summary>
            Controls how analyzers (and generators) are loaded 
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.BasicAnalyzerKind.Default">
            <summary>
            Default for the current runtime
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.BasicAnalyzerKind.InMemory">
            <summary>
            Analyzers are loaded in memory and disk is not used. 
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.BasicAnalyzerKind.OnDisk">
            <summary>
            Analyzers are written to disk and loaded from there. This will produce as a 
            side effect <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> instances. 
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.BasicAnalyzerKind.None">
            <summary>
            Analyzers and generators from the original are not loaded at all. In the case 
            the original build had generated files they will be added through an in 
            memory analyzer that just adds them directly.
            </summary>
            <remarks>
            This option avoids loading third party analyzers and generators.
            </remarks>
        </member>
        <member name="T:Basic.CompilerLog.Util.BasicAnalyzerHost">
            <summary>
            The set of analyzers loaded for a given <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.BasicAnalyzerHost.GetDiagnostics">
            <summary>
            Get the current set of diagnostics. This can change as analyzers can add them during 
            execution which can happen in parallel to analysis.
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.BinaryLogUtil.SkipCompilerExecutable(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            The argument list is going to include either `dotnet exec csc.dll` or `csc.exe`. Need 
            to skip past that to get to the real command line.
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.CompilationData.BasicAnalyzerHost">
            <summary>
            The <see cref="P:Basic.CompilerLog.Util.CompilationData.BasicAnalyzerHost"/> for the analyzers and generators.
            </summary>
            <remarks>
            This is *not* owned by this instance and should not be disposed from here. The creator
            of this <see cref="T:Basic.CompilerLog.Util.CompilationData"/> is responsible for managing the lifetime of this
            instance.
            </remarks>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilationData.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            This gets diagnostics from the compiler (does not include analyzers)
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilationData.GetAllDiagnosticsAsync(System.Threading.CancellationToken)">
            <summary>
            This gets diagnostics from the compiler and any attached analyzers.
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerCallKind.Regular">
            <summary>
            Standard compilation call that goes through the C# / VB targets
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerCallKind.Satellite">
            <summary>
            Compilation to build a satellite assembly
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerCallKind.WpfTemporaryCompile">
            <summary>
            Temporary assembly generated for WPF projects
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerCallKind.XamlPreCompile">
            <summary>
            Compilation that occurs in the XAML pipeline to create a temporary assembly used 
            to reflect on to generate types for the real compilation
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerCallKind.Unknown">
            <summary>
            Compilation that doesn't fit existing classifications
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogBuilder.AddGeneratedFiles(Basic.CompilerLog.Util.Serialize.CompilationDataPack,Microsoft.CodeAnalysis.CommandLineArguments,Basic.CompilerLog.Util.CompilerCall)">
            <summary>
            Attempt to add all the generated files from generators. When successful the generators
            don't need to be run when re-hydrating the compilation.
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogBuilder.AddContentMessagePack``1(``0)">
            <summary>
            Add the <paramref name="value"/> as content using message pack serialization
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogBuilder.AddContent(System.String)">
            <summary>
            Add a source file to the storage and return the stored name of the content in our 
            storage. This will be a checksum of the content itself
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogBuilder.AddContent(System.IO.Stream)">
            <summary>
            Add a source file to the storage and return the stored name of the content in our 
            storage. This will be a checksum of the content itself
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogBuilder.AddAssembly(System.String)">
            <summary>
            Add the assembly into the storage and return tis MVID
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.CompilerLogReader._zipArchiveCore">
            <summary>
            Stores the underlying archive this reader is using. Do not use directly. Instead 
            use <see cref="P:Basic.CompilerLog.Util.CompilerLogReader.ZipArchive"/>  which will throw if the reader is disposed
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.CompilerLogReader.OwnsCompilerLogState">
            <summary>
            Is this reader responsible for disposing the <see cref="P:Basic.CompilerLog.Util.CompilerLogReader.CompilerLogState"/> instance
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.CompilerLogState">
             <summary>
             The <see cref="T:Basic.CompilerLog.Util.CompilationData"/> have underlying state associated with them: 
                 - File system entries to hold crypto key files
                 - <see cref="T:Basic.CompilerLog.Util.BasicAnalyzerHost"/> which control loaded analyzers
            
             Rather than have each <see cref="T:Basic.CompilerLog.Util.CompilationData"/> maintain it's own and state
             and be disposable, all of it is stored here. Generally this is implicitly tied
             to the lifetime of a <see cref="T:Basic.CompilerLog.Util.CompilerLogReader"/> but this can be explicitly
             managed in cases where <see cref="T:Basic.CompilerLog.Util.CompilationData"/> live longer than the 
             underlying reader.
             </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.CompilerLogState.CryptoKeyFileDirectory">
            <summary>
            The compiler supports strong named keys that exist on disk. In order for compilation to succeed at the 
            Emit section, even for some binding purposes, that file must continue to exist on disk when the project
            is re-hydrated.
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.ConvertBinaryLogResult.CompilerCalls">
            <summary>
            The set of <see cref="T:Basic.CompilerLog.Util.CompilerCall"/> included in the log
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.ConvertBinaryLogResult.Diagnostics">
            <summary>
            The diagnostics produced during conversion
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.CompilerLogUtil.GetOrCreateCompilerLogStream(System.String)">
            <summary>
            Opens or creates a valid compiler log stream from the provided file path. The file path
            must refer to a binary or compiler log
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.EmitData">
            <summary>
            Data about a compilation that is only interesting at Emit time
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.ExportUtil">
            <summary>
            Tool to export compilations to disk for other uses
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.ExportUtil.ContentBuilder.WriteContent(System.String,System.IO.Stream)">
            <summary>
            Writes the content to the new directory structure and returns the full path of the 
            file that was written.
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.Extensions.AsSimpleMemoryStream(System.Byte[],System.Boolean)">
            <summary>
            Creates a <see cref="T:System.IO.MemoryStream"/> that is a simple wrapper around the array. The intent
            is for consumers to be able to access the underlying array via <see cref="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)"/>
            and similar methods.
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.Impl.BasicAnalyzerHostInMemory">
            <summary>
            Loads analyzers in memory
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.Impl.BasicAnalyzerHostNone">
            <summary>
            This is the analyzer host which doesn't actually run generators / analyzers. Instead it
            uses the source texts that were generated at the original build time.
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.Impl.NoneAnalyzerReference">
            <summary>
            Simple in memory generator for adding the pre-generated files in. 
            </summary>
            <remarks>
            Note: this cannot be a file local type because of a Roslyn bug on .NET Framework
            </remarks>
        </member>
        <member name="T:Basic.CompilerLog.Util.Impl.BasicAnalyzerHostOnDisk">
            <summary>
            This is a per-compilation analyzer assembly loader that can be used to produce 
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> instances
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.PathNormalizationUtil.IsPathRooted(System.String)">
            <summary>
            Is the path rooted in the "from" platform
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Basic.CompilerLog.Util.PathNormalizationUtil.NormalizePath(System.String)">
            <summary>
            Normalize the path from the "from" platform to the "to" platform
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:Basic.CompilerLog.Util.WindowsToUnixNormalizationUtil">
            <summary>
            This will normalize paths from Unix to Windows
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.WindowsToUnixNormalizationUtil.#ctor(System.String)">
            <summary>
            This will normalize paths from Unix to Windows
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.EmtpyNormalizationUtil">
            <summary>
            This is used when the current platform is the same as the platform that generated the log
            hence no normalization is needed.
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.RawContentKind.EmbedLine">
            <summary>
            This represents a #line directive target in a file that was embedded. These are different
            than normal line directives in that they are embedded into the compilation as well so the
            file is read from disk.
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.RawCompilationData.ReadGeneratedFiles">
            <summary>
            This is true when the generated files were successfully read from the original 
            compilation. This can be true when there are no generated files. A successful read
            for example happens on a compilation where there are no analyzers (successfully 
            read zero files)
            </summary>
        </member>
        <member name="T:Basic.CompilerLog.Util.ResilientDirectory">
            <summary>
            Abstraction for getting new file paths for original paths in the compilation.
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.ResilientDirectory._map">
            <summary>
            Content can exist outside the cone of the original project tree. That content 
            is mapped, by original directory name, to a new directory in the output. This
            holds the map from the old directory to the new one.
            </summary>
        </member>
        <member name="F:Basic.CompilerLog.Util.ResilientDirectory._flattenedMap">
            <summary>
            When doing flattening this holds the map of file name that was flattened to the 
            path that it was flattened from.
            </summary>
        </member>
        <member name="P:Basic.CompilerLog.Util.ResilientDirectory.Flatten">
            <summary>
            When true will attempt to flatten the directory structure by writing files
            directly to the directory when possible.
            </summary>
        </member>
        <member name="M:Basic.CompilerLog.Util.RoslynUtil.GetSourceText(System.IO.Stream,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Get a source text 
            </summary>
            <remarks>
            TODO: need to expose the real API for how the compiler reads source files. 
            move this comment to the rehydration code when we write it.
            </remarks>
        </member>
        <member name="M:Basic.CompilerLog.Util.PathUtil.ReplacePathStart(System.String,System.String,System.String)">
            <summary>
            Replace the <paramref name="oldStart"/> with <paramref name="newStart"/> inside of
            <paramref name="filePath"/>
            </summary>
        </member>
    </members>
</doc>
